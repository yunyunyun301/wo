# python学习笔记
## 一.列表
**1.** 基本格式：
列表名 = [元素1，元素2，元素3...]

__注意__:

- 所有元素放在[]内，元素之间用','隔开

- 元素的数据类型可以不相同

**2.** 列表是可迭代对象，可以for循环遍历取值

**3.** 列表的常见操作

i.添加元素
| 名称 | 用法 |说明 |
|------|------|:------|
|append()|li.append("要加入的内容")| 整体添加|
|extend()|li.extend("要加入的内容")| 分散添加|
|insert()|li.insert(插入位置，"要加入的内容")|在指定位置插入元素，原有元素会后移|

ii. 修改元素 

直接通过下标修改

iii.查找元素

* __in__：判断指定元素是否存在列表中，如果存在就返回True,不存在就返回False

```
lie = ['a','b','c']

print('a' in lie) #True
print('d' in lie) #False  
```
* __index__ : 返回指定数据所在位置的下标，如果查找的数据不存在就会报错
* __count__ :  统计指定数据在当前列表出现次数

iiii.删除元素
  
  * __del__ : 删除指定下标的元素   
  __del li[1]__ 
  * __pop__ ：删除指定下标的数据，python3版本默认删除最后一个元素，下标不能超出范围 
                                      
    **li.pop(num)**
  * **remove** :根据元素的值进行删除，没有指定元素就报错，默认删除第一个指定元素
 **li.remove(指定元素)**

iiiii.排序

* **sort**(key,reverse):将列表按特定顺序重新排列，默认从小到大
* **reverse**( ):将列表倒序
  
iiiiii.列表推导式

*  格式一：[表达式 for 变量 in 列表]

     **注意**:in后面不仅可以放列表，还可以放range()、可迭代对象

*  格式二：[表达式 for 变量 in 列表 if 条件]

iiiiiii.列表嵌套

含义：列表里又有一个列表

示例：

```
li =[1,2,3,[4,5,6]]                 #有点类似二维数组
print(li[1],li[3],li[3][2],sep='\n') 
'''输出结果
2

[4, 5, 6]

6'''
```

## 二.元组

2.1
* 格式：元组名 = (元素1，元素2，元素3)
* 所有元素放在()内，元素之间用','隔开
* 元素的数据类型可以不相同
* **注意**：只有一个元素，末尾必须加上逗号，否则返回唯一值的数据类型
  
2.2 元组与列表的区别

a.元组只有一个元素末尾必须加','  , 列表不需要<br>
b.元组只支持查询，不支持增删<br>
c.元组也有下标<br>

2.3 元组的应用场景<br>
a.函数的参数和返回值<br>
b.格式化输出本质上是元组<br>
c.元组数据不可修改，保护数据安全
## 三.字典


3.1 基本格式 ：字典名 = {键1：值1,键2：值2...}

* 以键值对形式保存，键和值之间用':'隔开，每个键值对用','隔开
* 字典中的键具备唯一性，但是值可以重复。键名重复前面的值会被后面的值替代

3.2 字典常见操作

3.2.1 查看元素

* 变量名[键名] 
* 变量名.get(键名)

```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic[1]) #报错，字典没有下标
print(dic['age']) #41
print(dic['sex']) #报错，键名不存在
print(dic.get('name')) #kobe
print(dic.get('sex')) #None
print(dic.get('sex','不存在'))#不存在，如果没有这个键名，返回自定义值
```
3.2.2 修改元素&新增元素

* 变量名[键名] = 值

**注意** 键名存在就修改，没有就新增
```
dic['name'] = 'laoda'
dic['sex'] = 'man'
print(dic)#{'name': 'laoda', 'age': 41, 'sex': 'man'}
```

3.2.3 删除元素

a. del 字典名 删除整个字典<br>
b. del 字典名[键名]  删除指定键值对，不存在就报错<br>
c.dic.clear()  清空字典,但保留这个字典<br>
d. dic.pop(键名)  删除指定键值对，并返回被删除的值,不存在就报错<br>
e. dic.popitem() 默认删除最后一个键值对并以元组形式返回被删除的键值对<br>

3.2.4 len() 求长度
* len(字典名) 返回字典中键值对的数量
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(len(dic)) #2
```
3.2.5 keys(): 返回所有键名(可迭代对象)
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic.keys()) #dict_keys(['name', 'age'])
for i in dic.keys():
    print(i)#name
             #age
```
3.2.6 values(): 返回字典中包含的所有值
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic.values()) #dict_values(['kobe', 41])
for i in dic.values():
    print(i)#kobe
             #41
```
3.2.7 items(): 返回字典中包含的所有键值对,以元组形式
```
for i in dic.items():
    print(i)#('name', 'kobe')
             #('age', 41)
```
3.2.8 字典的应用场景

a.存储结构化数据<br>
b.函数的参数传递<br>

## 四.集合
4.1 基本格式：集合名 = {元素1，元素2，元素3...}
* 所有元素放在{}内，元素之间用','隔开
* 元素的数据类型可以不相同
4.2 集合的特点

a.集合中的元素是无序的，不能通过下标访问集合中的元素，也不能修改<br>
```
s1 = {'a','b',3}
print(s[0]) #报错，集合没有下标
print(s) #{3, a, b}  #集合中的元素是无序的，每次输出的顺序可能不一样
s2 = {3,2,1}
print(s2) #{1, 2, 3} ,数字以升序输出
```
**集合无序性的实现涉及哈希表**

b.集合中的元素具有唯一性，重复元素会被自动去重<br>
```
s = {'a','b',3,'a'}
print(s) #{3, a, b}  
```
4.3 集合的常见操作

4.3.1 添加元素
* add()：添加单个元素
```
s = {1,2,3}
s.add(4)
print(s) #{1, 2, 3, 4}
#如果添加的元素已经存在，集合不会报错，同时不会进行任何操作
s.add(2)
print(s) #{1, 2, 3, 4}
#一次只能添加一个元素，不能添加多个元素
s.add(5,6) #报错
s.add((5,6)) #可以添加一个元组
print(s) #{1, 2, 3, 4, (5, 6)}
```
* update()：把传入元素拆分后添加到集合中
```
s = {1,2,3}
s.update('abc')
print(s) #{1, 2, 3, 'a', 'b', 'c'}
s.update([4,5])
print(s) #{1, 2, 3, 4, 5, 'a', 'b', 'c'}
s.update((6,7))
print(s) #{1, 2, 3, 4, 5, 6, 7, 'a', 'b', 'c'}
```
4.3.2 删除元素
* remove()：根据元素的值进行删除，没有指定元素就报错
* discard()：根据元素的值进行删除，没有指定元素不会报错
* pop()：随机删除并返回被删除的元素，集合为空时会报错
```
s = {1,2,3}
s.remove(2)
print(s) #{1, 3}  
s.remove(4) #报错，元素不存在
s.discard(4) #不会报错，元素不存在
s.pop() #删除最左边元素并返回被删除的元素
print(s) #{3}  #剩下一个元素
```
4.3.3 集合的交集、并集、差集
* 交集：返回两个集合中都存在的元素
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 & s2) #{2, 3}
```
* 并集：返回两个集合中所有的元素，重复元素只保留一个
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 | s2) #{1, 2, 3, 4}
```
* 差集：返回在第一个集合中存在但在第二个集合中不存在的元素
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 - s2) #{1}
print(s2 - s1) #{4}
```

## 五. 类型转换

5.1 

5.1.1 int()：将其他数据类型转换为整数类型，字符串必须是**数字**组成，否则会报错

5.1.2 float()：将其他数据类型转换为浮点数类型，字符串必须是**数字**组成，否则会报错

5.1.3 str()：将其他数据类型转换为字符串类型，**任何数据类型**都可以转换为字符串类型
          
5.1.4 bool()：将其他数据类型转换为布尔类型，以下数据类型转换为False：0、0.0、''、[]、()、{}、None，其他数据类型转换为True

5.1.5 list()：将可迭代对象转换为列表类型，**字符串**会被拆分成单个字符，**元组和集合**会被拆分成单个元素，**字典**会取键名

5.1.6 tuple()：将可迭代对象转换为元组类型，**字符串**会被拆分成单个字符，**列表和集合**会被拆分成单个元素，**字典**会取键名

5.1.7 eval()：将字符串类型转换为对应的数据类型，字符串必须是**合法的表达式**，否则会报错

5.1.8 set()：先去重，将可迭代对象转换为集合类型，**字符串**会被拆分成单个字符，**列表和元组**会被拆分成单个元素，**字典**会取键名

## 六.深浅拷贝,可变类型和不可变类型

6.1 浅拷贝：创建一个新的对象，拷贝第一层数据，嵌套层会指向原对象的内存地址
```py
import copy                                      #引入copy模块
li = [1,2,3,[4,5,6]]

li2 = li.copy()                                #浅拷贝

print(li)                                     #[1, 2, 3, [4, 5, 6]]
print(li2)                                    #[1, 2, 3, [4, 5, 6]]

print(id(li))                                 #内存地址
print(id(li2))                        #内存地址，浅拷贝后内存地址不同

li2[3][0] = 100                         #修改嵌套层数据
print(li)                                   #[1, 2, 3, [100, 5, 6]]
print(li2)                                  #[1, 2, 3, [100, 5, 6]]
print(id(li[3])) 
print(id(li2[3]))                 #内存地址，浅拷贝后嵌套层内存地址相同
```
* 优点：拷贝速度快，占用空间小，拷贝效率高
* 缺点：拷贝后原对象和新对象不完全独立，修改新对象的嵌套层数据会影响原对象

6.2 深拷贝：创建一个新的对象，拷贝所有层数据，嵌套层会指向新对象的内存地址
```py
import copy                                      #引入copy模块
li = [1,2,3,[4,5,6]]

li2 = copy.deepcopy(li)                                #深拷贝

print(li)                                     #[1, 2, 3, [4, 5, 6]]
print(li2)                                    #[1, 2, 3, [4, 5, 6]]

print(id(li))                                 #内存地址
print(id(li2))                        #内存地址，浅拷贝后内存地址不同

li2[3][0] = 100                         #修改嵌套层数据
print(li)                                   #[1, 2, 3, [4, 5, 6]]
print(li2)                                  #[1, 2, 3, [100, 5, 6]]
print(id(li[3])) 
print(id(li2[3]))                #内存地址，深拷贝后嵌套层内存地址不同
```
* 优点：拷贝后原对象和新对象完全独立，修改新对象不会影响原对象
* 缺点：拷贝速度慢，占用空间大，拷贝效率低

6.3 可变类型

含义 ：数据内容可以修改的类型，列表、字典、集合都是可变类型

变量名指向内存地址，内存地址指向数据内容，修改数据内容内存地址不变
```py
li = [1,2,3]
print(id(li)) #内存地址
li[0] = 100
print(li) #[100, 2, 3]
print(id(li)) #内存地址，修改数据内容内存地址不变。字典,集合同理
```
6.4 不可变类型

含义 ：数据内容不可以修改的类型，整数、浮点数、字符串、元组都是不可变类型

变量名指向内存地址，内存地址指向数据内容，修改数据内容内存地址改变
```py
a = 10
print(id(a))
a = 100
print(id(a)) #内存地址，修改数据内容内存地址改变。字符串,元组同理
```

## 七.函数

**定义** ：具有特定功能的代码块，可以重复使用

**格式** ：
```
def 函数名(参数1，参数2...):        
 #函数名遵循标识符命名规则，不能与内置函数重名，参数可以没有
 
    函数体     

  #函数执行时要执行的代码块，至少要有一行代码，如果没有代码可以用pass占位                 
    return 返回值

  #函数执行后返回的结果，可以没有返回值，默认返回None
  #return 后面的代码不会被执行
```
7.1 函数参数

7.1.1 必备参数（位置参数）：调用函数时必须传入的参数，实参和形参一一对应
格式：
```
def function(参数1，参数2...):
    函数体
```
7.1.2 默认参数：调用函数时可以不传入的参数，实参和形参一一对应，**默认参数必须放在必备参数后面**
格式：
```
def function(必备参数1，必备参数2...，默认参数1=默认值1，默认参数2=默认值2...):
    函数体
```
7.1.3 可变参数：调用函数时可以传入任意数量的参数，实参和形参不一一对应，**可变参数必须放在默认参数后面**
格式：
```
def function(必备参数1，必备参数2...，默认参数1=默认值1，默认参数2=默认值2...，*可变参数):                        #可变参数前面加*，函数体内可变参数会被当成一个元组
     函数体
```
7.1.4 关键字参数：调用函数时通过参数名传入的参数，实参和形参不一一对应，**关键字参数必须放在可变参数后面**
格式：
```
def function(必备参数1，必备参数2...，默认参数1=默认值1，默认参数2=默认值2...，*可变参数，**关键字参数):             
#关键字参数前面加**，函数体内关键字参数会被当成一个字典
     函数体
```
7.2 函数嵌套
定义：在一个函数内部定义另一个函数，内层函数可以访问外层函数的变量，但外层函数不能访问内层函数的变量

7.3 作用域

7.3.1 局部变量：在函数内部定义的变量只能在函数内部使用，函数执行结束后局部变量会被销毁

7.3.2 全局变量：在函数外部定义的变量可以在函数内部使用，函数执行结束后全局变量不会被销毁

7.3.3 

a. global关键字：在函数内部使用global关键字声明的变量是全局变量。

b. nonlocal关键字：在函数内部使用nonlocal关键字声明的变量是外层函数的局部变量。

示例
```
def outer():
    a = 10
    def inner():
        nonlocal a
        a = 100
    inner()
    print(a)         # nonlocal声明a是外层函数的局部变量，修改a的值会影响outer函数内a的值
outer()   #100
```

7.4 匿名函数

定义：没有函数名的函数，使用lambda关键字定义，**只能有一个表达式，不能有return语句**

格式：函数名 = lambda 形参1，形参2...:表达式(返回值)

调用：结果 = 函数名(实参1，实参2...)
``` py
add = lambda x,y:x+y
print(add(1,1)) #2
```

参数设置与普通函数一样，可以设置默认参数、可变参数、关键字参数

7.4.1 lambda结合if判断
```py
max = lambda x,y:x if x>y else y
print(max(1,2)) #2
``` 
优点：代码简洁，适合定义简单的函数

缺点：功能有限，适合定义简单的函数，不适合定义复杂的函数

7.5 内置函数

```py
#查看所有内置函数
import builtins
print(dir(builtins))
```

常用内置函数：
* abs()：返回数字的绝对值
* sum()：对可迭代对象中的元素进行求和,字符串和字典不适用
* max()：返回可迭代对象中的最大值,字符串和字典不适用
  
  ```py
  print(max(1,2,-3,key=abs)) #-3, key参数指定abs函数作为比较的依据，返回绝对值最大的元素
  ```
* min()：返回可迭代对象中的最小值,字符串和字典不适用
* len()：返回对象的长度或元素个数
* zip()：将可迭代对象中的元素打包成一个个元组，返回由这些元组组成的zip对象
```py
li =[1,2,3]
li2 = ['a','b']
print(zip(li,li2)) #<zip object at 0x0000021BC8B0>
for i in zip(li,li2):
    print(i) #(1, 'a')
             #(2, 'b')
             #如果可迭代对象的元素个数不一致，zip会以最短的可迭代对象为准进行打包         
#转换成列表             
print(list(zip(li,li2))) #[(1, 'a'), (2, 'b')]
```

* map()：将指定函数作用于可迭代对象的每个元素，返回由结果组成的map对象
```py
def func(x):
    return x**2
li = [1,2,3]
print(map(func,li)) #<map object at 0x0000021BC80>
for i in map(func,li):
    print(i) #1
             #4
             #9
#转换成列表             
print(list(map(func,li))) #[1, 4, 9]
```

* reduce()：将指定函数作用于可迭代对象的前两个元素，并将结果与下一个元素继续作用，直到所有元素被处理，返回最终结果
```py
#引入functools模块
from functools import reduce
def func(x,y):
    return x+y
li = [1,2,3,4]
print(reduce(func,li)) #10, 1+2=3, 3+3=6, 6+4=10
```

7.6  拆包

含义：对于函数中的多个返回值，去掉元组，列表或字典，直接获取里面数据的过程


```py
def func():
    return 1,2,3
#方法一:要求返回值的数量和变量的数量一致，且顺序一致
a,b,c = func()
print(a,b,c) #1 2 3
#方法二:使用*变量名接收多余的返回值，变量会被当成一个列表
a,*b = func()
print(a,b) #1 [2, 3]
```
