# python学习笔记
## 一.列表
**1.** 基本格式：
列表名 = [元素1，元素2，元素3...]

__注意__:

- 所有元素放在[]内，元素之间用','隔开

- 元素的数据类型可以不相同

**2.** 列表是可迭代对象，可以for循环遍历取值

**3.** 列表的常见操作

i.添加元素
| 名称 | 用法 |说明 |
|------|------|:------|
|append()|li.append("要加入的内容")| 整体添加|
|extend()|li.extend("要加入的内容")| 分散添加|
|insert()|li.insert(插入位置，"要加入的内容")|在指定位置插入元素，原有元素会后移|

ii. 修改元素 

直接通过下标修改

iii.查找元素

* __in__：判断指定元素是否存在列表中，如果存在就返回True,不存在就返回False

```
lie = ['a','b','c']

print('a' in lie) #True
print('d' in lie) #False  
```
* __index__ : 返回指定数据所在位置的下标，如果查找的数据不存在就会报错
* __count__ :  统计指定数据在当前列表出现次数

iiii.删除元素
  
  * __del__ : 删除指定下标的元素   
  __del li[1]__ 
  * __pop__ ：删除指定下标的数据，python3版本默认删除最后一个元素，下标不能超出范围 
                                      
    **li.pop(num)**
  * **remove** :根据元素的值进行删除，没有指定元素就报错，默认删除第一个指定元素

    **li.remove(指定元素)**

iiiii.排序

* **sort**(key,reverse):将列表按特定顺序重新排列，默认从小到大
* **reverse**( ):将列表倒序
  
iiiiii.列表推导式

*  格式一：结果 = [表达式 for 变量 in 列表]

     **注意**:in后面不仅可以放列表，还可以放range()、可迭代对象

*  格式二：[表达式 for 变量 in 列表 if 条件]

iiiiiii.列表嵌套

含义：列表里又有一个列表

示例：

```py
li =[1,2,3,[4,5,6]]                 #有点类似二维数组
print(li[1],li[3],li[3][2],sep='\n') 
'''输出结果
2

[4, 5, 6]

6'''
```

## 二.元组

2.1
* 格式：元组名 = (元素1，元素2，元素3)
* 所有元素放在()内，元素之间用','隔开
* 元素的数据类型可以不相同
* **注意**：只有一个元素，末尾必须加上逗号，否则返回唯一值的数据类型
  
2.2 元组与列表的区别

a.元组只有一个元素末尾必须加','  , 列表不需要<br>
b.元组只支持查询，不支持增删<br>
c.元组也有下标<br>

2.3 元组的应用场景<br>
a.函数的参数和返回值<br>
b.格式化输出本质上是元组<br>
c.元组数据不可修改，保护数据安全
## 三.字典


3.1 基本格式 ：字典名 = {键1：值1,键2：值2...}

* 以键值对形式保存，键和值之间用':'隔开，每个键值对用','隔开
* 字典中的键具备唯一性，但是值可以重复。键名重复前面的值会被后面的值替代

3.2 字典常见操作

3.2.1 查看元素

* 变量名[键名] 
* 变量名.get(键名)

```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic[1]) #报错，字典没有下标
print(dic['age']) #41
print(dic['sex']) #报错，键名不存在
print(dic.get('name')) #kobe
print(dic.get('sex')) #None
print(dic.get('sex','不存在'))#不存在，如果没有这个键名，返回自定义值
```
3.2.2 修改元素&新增元素

* 变量名[键名] = 值

**注意** 键名存在就修改，没有就新增
```
dic['name'] = 'laoda'
dic['sex'] = 'man'
print(dic)#{'name': 'laoda', 'age': 41, 'sex': 'man'}
```

3.2.3 删除元素

a. del 字典名 删除整个字典<br>
b. del 字典名[键名]  删除指定键值对，不存在就报错<br>
c. dic.clear()  清空字典,但保留这个字典<br>
d. dic.pop(键名)  删除指定键值对，并返回被删除的值,不存在就报错<br>
e. dic.popitem() 默认删除最后一个键值对并以元组形式返回被删除的键值对<br>

3.2.4 len() 求长度
* len(字典名) 返回字典中键值对的数量
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(len(dic)) #2
```
3.2.5 keys(): 返回所有键名(可迭代对象)
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic.keys()) #dict_keys(['name', 'age'])
for i in dic.keys():
    print(i)#name
             #age
```
3.2.6 values(): 返回字典中包含的所有值
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic.values()) #dict_values(['kobe', 41])
for i in dic.values():
    print(i)#kobe
             #41
```
3.2.7 items(): 返回字典中包含的所有键值对,以元组形式
```
for i in dic.items():
    print(i)#('name', 'kobe')
             #('age', 41)
```
3.2.8 字典的应用场景

a.存储结构化数据<br>
b.函数的参数传递<br>

## 四.集合
4.1 基本格式：集合名 = {元素1，元素2，元素3...}
* 所有元素放在{}内，元素之间用','隔开
* 元素的数据类型可以不相同
4.2 集合的特点

a.集合中的元素是无序的，不能通过下标访问集合中的元素，也不能修改<br>
```
s1 = {'a','b',3}
print(s[0]) #报错，集合没有下标
print(s) #{3, a, b}  #集合中的元素是无序的，每次输出的顺序可能不一样
s2 = {3,2,1}
print(s2) #{1, 2, 3} ,数字以升序输出
```
**集合无序性的实现涉及哈希表**

b.集合中的元素具有唯一性，重复元素会被自动去重<br>
```
s = {'a','b',3,'a'}
print(s) #{3, a, b}  
```
4.3 集合的常见操作

4.3.1 添加元素
* add()：添加单个元素
```
s = {1,2,3}
s.add(4)
print(s) #{1, 2, 3, 4}
#如果添加的元素已经存在，集合不会报错，同时不会进行任何操作
s.add(2)
print(s) #{1, 2, 3, 4}
#一次只能添加一个元素，不能添加多个元素
s.add(5,6) #报错
s.add((5,6)) #可以添加一个元组
print(s) #{1, 2, 3, 4, (5, 6)}
```
* update()：把传入元素拆分后添加到集合中
```
s = {1,2,3}
s.update('abc')
print(s) #{1, 2, 3, 'a', 'b', 'c'}
s.update([4,5])
print(s) #{1, 2, 3, 4, 5, 'a', 'b', 'c'}
s.update((6,7))
print(s) #{1, 2, 3, 4, 5, 6, 7, 'a', 'b', 'c'}
```
4.3.2 删除元素
* remove()：根据元素的值进行删除，没有指定元素就报错
* discard()：根据元素的值进行删除，没有指定元素不会报错
* pop()：随机删除并返回被删除的元素，集合为空时会报错
```
s = {1,2,3}
s.remove(2)
print(s) #{1, 3}  
s.remove(4) #报错，元素不存在
s.discard(4) #不会报错，元素不存在
s.pop() #删除最左边元素并返回被删除的元素
print(s) #{3}  #剩下一个元素
```
4.3.3 集合的交集、并集、差集
* 交集：返回两个集合中都存在的元素
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 & s2) #{2, 3}
```
* 并集：返回两个集合中所有的元素，重复元素只保留一个
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 | s2) #{1, 2, 3, 4}
```
* 差集：返回在第一个集合中存在但在第二个集合中不存在的元素
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 - s2) #{1}
print(s2 - s1) #{4}
```

## 五. 类型转换

5.1 

5.1.1 int()：将其他数据类型转换为整数类型，字符串必须是**数字**组成，否则会报错

5.1.2 float()：将其他数据类型转换为浮点数类型，字符串必须是**数字**组成，否则会报错

5.1.3 str()：将其他数据类型转换为字符串类型，**任何数据类型**都可以转换为字符串类型
          
5.1.4 bool()：将其他数据类型转换为布尔类型，以下数据类型转换为False：0、0.0、''、[]、()、{}、None，其他数据类型转换为True

5.1.5 list()：将可迭代对象转换为列表类型，**字符串**会被拆分成单个字符，**元组和集合**会被拆分成单个元素，**字典**会取键名

5.1.6 tuple()：将可迭代对象转换为元组类型，**字符串**会被拆分成单个字符，**列表和集合**会被拆分成单个元素，**字典**会取键名

5.1.7 eval()：将字符串类型转换为对应的数据类型，字符串必须是**合法的表达式**，否则会报错

5.1.8 set()：先去重，将可迭代对象转换为集合类型，**字符串**会被拆分成单个字符，**列表和元组**会被拆分成单个元素，**字典**会取键名

## 六.深浅拷贝,可变类型和不可变类型

6.1 浅拷贝：创建一个新的对象，拷贝第一层数据，嵌套层会指向原对象的内存地址
```py
import copy                                      #引入copy模块
li = [1,2,3,[4,5,6]]

li2 = li.copy()                                #浅拷贝

print(li)                                     #[1, 2, 3, [4, 5, 6]]
print(li2)                                    #[1, 2, 3, [4, 5, 6]]

print(id(li))                                 #内存地址
print(id(li2))                        #内存地址，浅拷贝后内存地址不同

li2[3][0] = 100                         #修改嵌套层数据
print(li)                                   #[1, 2, 3, [100, 5, 6]]
print(li2)                                  #[1, 2, 3, [100, 5, 6]]
print(id(li[3])) 
print(id(li2[3]))                 #内存地址，浅拷贝后嵌套层内存地址相同
```
* 优点：拷贝速度快，占用空间小，拷贝效率高
* 缺点：拷贝后原对象和新对象不完全独立，修改新对象的嵌套层数据会影响原对象

6.2 深拷贝：创建一个新的对象，拷贝所有层数据，嵌套层会指向新对象的内存地址
```py
import copy                                      #引入copy模块
li = [1,2,3,[4,5,6]]

li2 = copy.deepcopy(li)                                #深拷贝

print(li)                                     #[1, 2, 3, [4, 5, 6]]
print(li2)                                    #[1, 2, 3, [4, 5, 6]]

print(id(li))                                 #内存地址
print(id(li2))                        #内存地址，浅拷贝后内存地址不同

li2[3][0] = 100                         #修改嵌套层数据
print(li)                                   #[1, 2, 3, [4, 5, 6]]
print(li2)                                  #[1, 2, 3, [100, 5, 6]]
print(id(li[3])) 
print(id(li2[3]))                #内存地址，深拷贝后嵌套层内存地址不同
```
* 优点：拷贝后原对象和新对象完全独立，修改新对象不会影响原对象
* 缺点：拷贝速度慢，占用空间大，拷贝效率低

6.3 可变类型

含义 ：数据内容可以修改的类型，列表、字典、集合都是可变类型

变量名指向内存地址，内存地址指向数据内容，修改数据内容内存地址不变
```py
li = [1,2,3]
print(id(li)) #内存地址
li[0] = 100
print(li) #[100, 2, 3]
print(id(li)) #内存地址，修改数据内容内存地址不变。字典,集合同理
```
6.4 不可变类型

含义 ：数据内容不可以修改的类型，整数、浮点数、字符串、元组都是不可变类型

变量名指向内存地址，内存地址指向数据内容，修改数据内容内存地址改变
```py
a = 10
print(id(a))
a = 100
print(id(a)) #内存地址，修改数据内容内存地址改变。字符串,元组同理
```

## 七.函数

**定义** ：具有特定功能的代码块，可以重复使用

**格式** ：
```
def 函数名(参数1，参数2...):        
 #函数名遵循标识符命名规则，不能与内置函数重名，参数可以没有
 
    函数体     

  #函数执行时要执行的代码块，至少要有一行代码，如果没有代码可以用pass占位                 
    return 返回值

  #函数执行后返回的结果，可以没有返回值，默认返回None
  #return 后面的代码不会被执行
```
7.1 函数参数

7.1.1 必备参数（位置参数）：调用函数时必须传入的参数，实参和形参一一对应
格式：
```
def function(参数1，参数2...):
    函数体
```
7.1.2 默认参数：调用函数时可以不传入的参数，实参和形参一一对应，**默认参数必须放在必备参数后面**
格式：
```
def function(必备参数1，必备参数2...，默认参数1=默认值1，默认参数2=默认值2...):
    函数体
```
7.1.3 可变参数：调用函数时可以传入任意数量的参数，实参和形参不一一对应，**可变参数必须放在默认参数后面**
格式：
```
def function(必备参数1，必备参数2...，默认参数1=默认值1，默认参数2=默认值2...，*可变参数):                        #可变参数前面加*，函数体内可变参数会被当成一个元组
     函数体
```
7.1.4 关键字参数：调用函数时通过参数名传入的参数，实参和形参不一一对应，**关键字参数必须放在可变参数后面**
格式：
```
def function(必备参数1，必备参数2...，默认参数1=默认值1，默认参数2=默认值2...，*可变参数，**关键字参数):             
#关键字参数前面加**，函数体内关键字参数会被当成一个字典
     函数体
```
7.2 函数嵌套
定义：在一个函数内部定义另一个函数，内层函数可以访问外层函数的变量，但外层函数不能访问内层函数的变量

7.3 作用域

7.3.1 局部变量：在函数内部定义的变量只能在函数内部使用，函数执行结束后局部变量会被销毁

7.3.2 全局变量：在函数外部定义的变量可以在函数内部使用，函数执行结束后全局变量不会被销毁

7.3.3 

a. global关键字：在函数内部使用global关键字声明的变量是全局变量。

b. nonlocal关键字：在函数内部使用nonlocal关键字声明的变量是外层函数的局部变量。

示例
```py
def outer():
    a = 10
    def inner():
        nonlocal a
        a = 100
    inner()
    print(a)         # nonlocal声明a是外层函数的局部变量，修改a的值会影响outer函数内a的值
outer()   #100
```

7.4 匿名函数

定义：没有函数名的函数，使用lambda关键字定义，**只能有一个表达式，不能有return语句**

格式：函数名 = lambda 形参1，形参2...:表达式(返回值)

调用：结果 = 函数名(实参1，实参2...)
``` py
add = lambda x,y:x+y
print(add(1,1)) #2
```

参数设置与普通函数一样，可以设置默认参数、可变参数、关键字参数

7.4.1 lambda结合if判断
```py
max = lambda x,y:x if x>y else y
print(max(1,2)) #2
``` 
优点：代码简洁，适合定义简单的函数

缺点：功能有限，适合定义简单的函数，不适合定义复杂的函数

7.5 内置函数

```py
#查看所有内置函数
import builtins
print(dir(builtins))
```

常用内置函数：
* abs()：返回数字的绝对值
* sum()：对可迭代对象中的元素进行求和,字符串和字典不适用
* max()：返回可迭代对象中的最大值,字符串和字典不适用
  
  ```py
  print(max(1,2,-3,key=abs)) #-3, key参数指定abs函数作为比较的依据，返回绝对值最大的元素
  ```
* min()：返回可迭代对象中的最小值,字符串和字典不适用
* len()：返回对象的长度或元素个数
* zip()：将可迭代对象中的元素打包成一个个元组，返回由这些元组组成的zip对象
```py
li =[1,2,3]
li2 = ['a','b']
print(zip(li,li2)) #<zip object at 0x0000021BC8B0>
for i in zip(li,li2):
    print(i) #(1, 'a')
             #(2, 'b')
             #如果可迭代对象的元素个数不一致，zip会以最短的可迭代对象为准进行打包         
#转换成列表             
print(list(zip(li,li2))) #[(1, 'a'), (2, 'b')]
```

* map()：将指定函数作用于可迭代对象的每个元素，返回由结果组成的map对象
```py
def func(x):
    return x**2
li = [1,2,3]
print(map(func,li)) #<map object at 0x0000021BC80>
for i in map(func,li):
    print(i) #1
             #4
             #9
#转换成列表             
print(list(map(func,li))) #[1, 4, 9]
```

* reduce()：将指定函数作用于可迭代对象的前两个元素，并将结果与下一个元素继续作用，直到所有元素被处理，返回最终结果
```py
#引入functools模块
from functools import reduce
def func(x,y):
    return x+y
li = [1,2,3,4]
print(reduce(func,li)) #10, 1+2=3, 3+3=6, 6+4=10
```

7.6  拆包

含义：对于函数中的多个返回值，去掉元组，列表或字典，直接获取里面数据的过程


```py
def func():
    return 1,2,3
#方法一:要求返回值的数量和变量的数量一致，且顺序一致
a,b,c = func()
print(a,b,c) #1 2 3
#方法二:使用*变量名接收多余的返回值，变量会被当成一个列表
a,*b = func()
print(a,b) #1 [2, 3]
```

7.7 递归

定义：在函数内部调用函数本身的过程

优点：代码简洁，适合解决分治问题

缺点：递归层数过多会导致栈溢出，效率较低


7.8 函数引用

定义：函数也是一种数据类型，可以被赋值给变量，变量可以调用函数
```py
def func():
    print('hello')
greet = func #将函数func的引用赋值给变量greet
greet() #调用变量greet，输出hello
```
7.9 闭包

定义：在一个函数内部定义另一个函数，内层函数可以访问外层函数的变量，并且外层函数返回内层函数的引用

```py
def outer(x):
    def inner(y):
        return x+y
    return inner
add = outer(10) #调用outer函数，传入实参10，返回inner函数的引用，并将x的值绑定为10
print(add(5)) #调用add函数，传入实参5，返回x+y的结果，即10+5=15
```
7.10 装饰器

定义：装饰器本质上是一个闭包函数，在不修改函数代码的前提下，给函数增加额外功能的函数

条件：

1. 不修改原程序或函数的代码
2. 不修改原程序或函数的调用方式

7.10.1 标准版装饰器
```py
def decorator(func): #定义装饰器函数，参数func是被装饰的函数
    def wrapper(*args,**kwargs): #定义包装函数，接收被装饰函数的参数
        print('这是装饰器增加的功能') #在调用被装饰函数前增加的功能
        result = func(*args,**kwargs) #调用被装饰函数，并将结果保存到result变量中
        print('这是装饰器增加的功能') #在调用被装饰函数后增加的功能
        return result #返回被装饰函数的结果
    return wrapper #返回包装函数的引用
def func(x):
    print('这是被装饰的函数') #被装饰函数的功能
    return x**2 #被装饰函数的返回值
func = decorator(func) #使用装饰器装饰函数，返回包装函数的引用，并将其赋值给func变量
print(func(5)) #调用被装饰函数，输出装饰器增加的功能、被装饰的函数和装饰器增加的功能，最后输出被装饰函数的返回值
```

7.10.2 语法糖版装饰器

语法糖：在不改变程序功能的前提下，使用更简洁的语法来实现相同功能的代码

语句：@装饰器函数名，放在被装饰函数的定义前面，等价于被装饰函数 = 装饰器函数(被装饰函数)
```py
def decorator(func): #定义装饰器函数，参数func是被装饰的函数
    def wrapper(*args,**kwargs): #定义包装函数，接收被装饰函数的参数
        #(接收的参数要与被装饰函数的参数一致)
        print('这是装饰器增加的功能') #在调用被装饰函数前增加的功能
        result = func(*args,**kwargs) #调用被装饰函数，并将结果保存到result变量中
        print('这是装饰器增加的功能') #在调用被装饰函数后增加的功能
        return result #返回被装饰函数的结果
    return wrapper #返回包装函数的引用
@decorator #使用@符号将装饰器应用于函数，等价于func = decorator(func)
def func(x):
    print('这是被装饰的函数') #被装饰函数的功能
    return x**2 #被装饰函数的返回值
print(func(5)) #调用被装饰函数，输出装饰器增加的功能、被装饰的函数和装饰器增加的功能，最后输出被装饰函数的返回值
```
7.10.3 多层装饰器
定义：一个函数被多个装饰器装饰的情况，装饰器的执行顺序是从内到外，离函数最近的装饰器先装饰，即先执行最内层的装饰器，再执行外层的装饰器
```py
def decorator1(func):
    def wrapper(*args,**kwargs):
        print('这是装饰器1增加的功能')
        result = func(*args,**kwargs)
        print('这是装饰器1增加的功能')
        return result
    return wrapper
def decorator2(func):
    def wrapper(*args,**kwargs):
        print('这是装饰器2增加的功能')
        result = func(*args,**kwargs)
        print('这是装饰器2增加的功能')
        return result
    return wrapper
@decorator1
@decorator2
def func(x):
    print('这是被装饰的函数') #被装饰函数的功能
    return x**2 #被装饰函数的返回值
print(func(5)) #调用被装饰函数，输出装饰器增加的功能、被装饰的函数和装饰器增加的功能，最后输出被装饰函数的返回值
```
## 八.异常

8.1 异常类别

* NameError：变量名错误，访问了未定义的变量

* SyntaxError：语法错误，代码不符合Python的语法规则

* TypeError：类型错误，操作或函数应用于错误类型的对象
  
* ValueError：值错误，传入了正确类型但不合适的值

* IndexError：索引错误，访问了序列中不存在的索引

* KeyError：键错误，访问了字典中不存在的键

* ZeroDivisionError：零除错误，除数为零时发生

* IndentationError：缩进错误，代码块的缩进不正确

8.2 抛出异常

步骤：

1.创建一个Exception('xxx')对象，括号内可以传入异常信息

2.使用raise关键字抛出异常对象

```py
def func(x):
    if x < 0:
        raise Exception('x不能为负数') #抛出异常对象
    return x**2
print(func(-1)) #报错，x不能为负数
```

8.3 捕获异常

定义：当程序发生异常时，使用try...except语句捕获异常并进行处理，避免程序崩溃

使用try...except语句捕获异常

```
try:
    #可能发生异常的代码块
except Exception as e:
    #处理异常的代码块，e是捕获到的异常对象
```

## 九.模块和包

9.1 模块分类：一个.py文件就是一个模块，模块中可以定义函数、变量、类等

9.1.1 内置模块：Python自带的模块，可以直接使用，无需安装

如：random模块、math模块、time模块等

9.1.2 第三方模块：需要通过pip安装的模块

下载第三方模块：在命令行输入pip install 模块名

9.1.3 自定义模块：自己创建的模块

* 命名：模块名应遵循Python命名规范，使用小写字母、数字和下划线组成，避免使用Python关键字和内置模块名

9.2 导入模块

9.2.1 import 模块名：导入整个模块，使用模块名.函数名调用模块中的函数

语法：

导入模块：
```py
import 模块名
```

调用模块中的函数,变量：
```py
模块名.函数名(实参)
模块名.变量名
```

9.2.2 from 模块名 import 函数名,变量名：从模块中导入指定函数，直接使用函数名调用模块中的函数

语法：
```py
from 模块名 import 函数名
```
调用模块中的函数,变量：
```py
函数名(实参)
变量名
```

9.2.3 from 模块名 import *：从模块中导入所有函数，直接使用函数名调用模块中的函数

语法：
```py
from 模块名 import *     
```

**注意** :不建议使用这种方式导入模块，因为可能会导致命名冲突，无法确定函数的来源

9.2.4 

as：给模块或函数起别名，使用别名调用模块或函数

语法：
```py
import 模块名 as 别名
from 模块名 import 函数名1 as 别名,函数名2 as 别名
```

9.3 内置全局变量

* \_\_name__：当前模块的名字，如果是主模块，值为'\_\_main__'，如果是被导入的模块，值为模块名

```py
if __name__ == '__main__':
 #判断当前模块是否是主模块，如果是主模块就执行if语句块中的代码，如果是被导入的模块就执行else语句块中的代码
    print('这是主模块')
else:
    print('这是被导入的模块')
```

9.4 包

概念：包是一个包含多个模块的文件夹，包中必须有一个\_\_init__.py文件，\_\_init__.py文件可以是空的，也可以包含包的初始化代码。

作用：包将有关联的模块组织在一起，方便管理和使用

9.4.1 import 包名.模块名：导入包中的模块，使用包名.模块名.函数名调用模块中的函数

**注意：**  
* 如果包中有\_\_init__.py文件，导入包时会执行\_\_init__.py文件中的代码，如果\_\_init__.py文件中没有代码，导入包时不会执行任何代码

9.4.2 \_\_all\_\_：本质上时一个列表，列表里面的元素就代表要导入的模块

```py
#包的__init__.py文件
__all__ = ['模块名1','模块名2'...] #当使用from 包名 import *导入包时，只会导入__all__列表中指定的模块，其他模块不会被导入
```

9.4.3 包可以嵌套包：包中可以包含子包，子包中可以包含模块，导入子包中的模块时需要使用包名.子包名.模块名.函数名调用模块中的函数

