# python学习笔记
## 一.列表
**1.** 基本格式：
列表名 = [元素1，元素2，元素3...]

__注意__:

- 所有元素放在[]内，元素之间用','隔开

- 元素的数据类型可以不相同

**2.** 列表是可迭代对象，可以for循环遍历取值

**3.** 列表的常见操作

i.添加元素
| 名称 | 用法 |说明 |
|------|------|:------|
|append()|li.append("要加入的内容")| 整体添加|
|extend()|li.extend("要加入的内容")| 分散添加|
|insert()|li.insert(插入位置，"要加入的内容")|在指定位置插入元素，原有元素会后移|

ii. 修改元素 

直接通过下标修改

iii.查找元素

* __in__：判断指定元素是否存在列表中，如果存在就返回True,不存在就返回False

```
lie = ['a','b','c']

print('a' in lie) #True
print('d' in lie) #False  
```
* __index__ : 返回指定数据所在位置的下标，如果查找的数据不存在就会报错
* __count__ :  统计指定数据在当前列表出现次数

iiii.删除元素
  
  * __del__ : 删除指定下标的元素   
  __del li[1]__ 
  * __pop__ ：删除指定下标的数据，python3版本默认删除最后一个元素，下标不能超出范围 
                                      
    **li.pop(num)**
  * **remove** :根据元素的值进行删除，没有指定元素就报错，默认删除第一个指定元素
 **li.remove(指定元素)**

iiiii.排序

* **sort**(key,reverse):将列表按特定顺序重新排列，默认从小到大
* **reverse**( ):将列表倒序
  
iiiiii.列表推导式

*  格式一：[表达式 for 变量 in 列表]

     **注意**:in后面不仅可以放列表，还可以放range()、可迭代对象

*  格式二：[表达式 for 变量 in 列表 if 条件]

iiiiiii.列表嵌套

含义：列表里又有一个列表

示例：

```
li =[1,2,3,[4,5,6]]                 #有点类似二维数组
print(li[1],li[3],li[3][2],sep='\n') 
'''输出结果
2

[4, 5, 6]

6'''
```

## 二.元组

2.1
* 格式：元组名 = (元素1，元素2，元素3)
* 所有元素放在()内，元素之间用','隔开
* 元素的数据类型可以不相同
* **注意**：只有一个元素，末尾必须加上逗号，否则返回唯一值的数据类型
  
2.2 元组与列表的区别

a.元组只有一个元素末尾必须加','  , 列表不需要<br>
b.元组只支持查询，不支持增删<br>
c.元组也有下标<br>

2.3 元组的应用场景<br>
a.函数的参数和返回值<br>
b.格式化输出本质上是元组<br>
c.元组数据不可修改，保护数据安全
## 三.字典


3.1 基本格式 ：字典名 = {键1：值1,键2：值2...}

* 以键值对形式保存，键和值之间用':'隔开，每个键值对用','隔开
* 字典中的键具备唯一性，但是值可以重复。键名重复前面的值会被后面的值替代

3.2 字典常见操作

3.2.1 查看元素

* 变量名[键名] 
* 变量名.get(键名)

```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic[1]) #报错，字典没有下标
print(dic['age']) #41
print(dic['sex']) #报错，键名不存在
print(dic.get('name')) #kobe
print(dic.get('sex')) #None
print(dic.get('sex','不存在'))#不存在，如果没有这个键名，返回自定义值
```
3.2.2 修改元素&新增元素

* 变量名[键名] = 值

**注意** 键名存在就修改，没有就新增
```
dic['name'] = 'laoda'
dic['sex'] = 'man'
print(dic)#{'name': 'laoda', 'age': 41, 'sex': 'man'}
```

3.2.3 删除元素

a. del 字典名 删除整个字典<br>
b. del 字典名[键名]  删除指定键值对，不存在就报错<br>
c.dic.clear()  清空字典,但保留这个字典<br>
d. dic.pop(键名)  删除指定键值对，并返回被删除的值,不存在就报错<br>
e. dic.popitem() 默认删除最后一个键值对并以元组形式返回被删除的键值对<br>

3.2.4 len() 求长度
* len(字典名) 返回字典中键值对的数量
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(len(dic)) #2
```
3.2.5 keys(): 返回所有键名(可迭代对象)
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic.keys()) #dict_keys(['name', 'age'])
for i in dic.keys():
    print(i)#name
             #age
```
3.2.6 values(): 返回字典中包含的所有值
```
dic = {'name' : 'kobe' , 'age' : 41 }
print(dic.values()) #dict_values(['kobe', 41])
for i in dic.values():
    print(i)#kobe
             #41
```
3.2.7 items(): 返回字典中包含的所有键值对,以元组形式
```
for i in dic.items():
    print(i)#('name', 'kobe')
             #('age', 41)
```
3.2.8 字典的应用场景

a.存储结构化数据<br>
b.函数的参数传递<br>

## 四.集合
4.1 基本格式：集合名 = {元素1，元素2，元素3...}
* 所有元素放在{}内，元素之间用','隔开
* 元素的数据类型可以不相同
4.2 集合的特点

a.集合中的元素是无序的，不能通过下标访问集合中的元素，也不能修改<br>
```
s1 = {'a','b',3}
print(s[0]) #报错，集合没有下标
print(s) #{3, a, b}  #集合中的元素是无序的，每次输出的顺序可能不一样
s2 = {3,2,1}
print(s2) #{1, 2, 3} ,数字以升序输出
```
**集合无序性的实现涉及哈希表**

b.集合中的元素具有唯一性，重复元素会被自动去重<br>
```
s = {'a','b',3,'a'}
print(s) #{3, a, b}  
```
4.3 集合的常见操作

4.3.1 添加元素
* add()：添加单个元素
```
s = {1,2,3}
s.add(4)
print(s) #{1, 2, 3, 4}
#如果添加的元素已经存在，集合不会报错，同时不会进行任何操作
s.add(2)
print(s) #{1, 2, 3, 4}
#一次只能添加一个元素，不能添加多个元素
s.add(5,6) #报错
s.add((5,6)) #可以添加一个元组
print(s) #{1, 2, 3, 4, (5, 6)}
```
* update()：把传入元素拆分后添加到集合中
```
s = {1,2,3}
s.update('abc')
print(s) #{1, 2, 3, 'a', 'b', 'c'}
s.update([4,5])
print(s) #{1, 2, 3, 4, 5, 'a', 'b', 'c'}
s.update((6,7))
print(s) #{1, 2, 3, 4, 5, 6, 7, 'a', 'b', 'c'}
```
4.3.2 删除元素
* remove()：根据元素的值进行删除，没有指定元素就报错
* discard()：根据元素的值进行删除，没有指定元素不会报错
* pop()：随机删除并返回被删除的元素，集合为空时会报错
```
s = {1,2,3}
s.remove(2)
print(s) #{1, 3}  
s.remove(4) #报错，元素不存在
s.discard(4) #不会报错，元素不存在
s.pop() #删除最左边元素并返回被删除的元素
print(s) #{3}  #剩下一个元素
```
4.3.3 集合的交集、并集、差集
* 交集：返回两个集合中都存在的元素
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 & s2) #{2, 3}
```
* 并集：返回两个集合中所有的元素，重复元素只保留一个
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 | s2) #{1, 2, 3, 4}
```
* 差集：返回在第一个集合中存在但在第二个集合中不存在的元素
```
s1 = {1,2,3}
s2 = {2,3,4}
print(s1 - s2) #{1}
print(s2 - s1) #{4}
```

## 五. 类型转换

5.1 

5.1.1 int()：将其他数据类型转换为整数类型，字符串必须是**数字**组成，否则会报错

5.1.2 float()：将其他数据类型转换为浮点数类型，字符串必须是**数字**组成，否则会报错

5.1.3 str()：将其他数据类型转换为字符串类型，**任何数据类型**都可以转换为字符串类型
          
5.1.4 bool()：将其他数据类型转换为布尔类型，以下数据类型转换为False：0、0.0、''、[]、()、{}、None，其他数据类型转换为True

5.1.5 list()：将可迭代对象转换为列表类型，**字符串**会被拆分成单个字符，**元组和集合**会被拆分成单个元素，**字典**会取键名

5.1.6 tuple()：将可迭代对象转换为元组类型，**字符串**会被拆分成单个字符，**列表和集合**会被拆分成单个元素，**字典**会取键名

5.1.7 eval()：将字符串类型转换为对应的数据类型，字符串必须是**合法的表达式**，否则会报错

5.1.8 set()：先去重，将可迭代对象转换为集合类型，**字符串**会被拆分成单个字符，**列表和元组**会被拆分成单个元素，**字典**会取键名

## 六.深浅拷贝,可变类型和不可变类型

6.1 浅拷贝：创建一个新的对象，拷贝第一层数据，嵌套层会指向原对象的内存地址
```
import copy                                      #引入copy模块
li = [1,2,3,[4,5,6]]

li2 = li.copy()                                #浅拷贝

print(li)                                     #[1, 2, 3, [4, 5, 6]]
print(li2)                                    #[1, 2, 3, [4, 5, 6]]

print(id(li))                                 #内存地址
print(id(li2))                        #内存地址，浅拷贝后内存地址不同

li2[3][0] = 100                         #修改嵌套层数据
print(li)                                   #[1, 2, 3, [100, 5, 6]]
print(li2)                                  #[1, 2, 3, [100, 5, 6]]
print(id(li[3])) 
print(id(li2[3]))                 #内存地址，浅拷贝后嵌套层内存地址相同
```
* 优点：拷贝速度快，占用空间小，拷贝效率高
* 缺点：拷贝后原对象和新对象不完全独立，修改新对象的嵌套层数据会影响原对象

6.2 深拷贝：创建一个新的对象，拷贝所有层数据，嵌套层会指向新对象的内存地址
```
import copy                                      #引入copy模块
li = [1,2,3,[4,5,6]]

li2 = copy.deepcopy(li)                                #深拷贝

print(li)                                     #[1, 2, 3, [4, 5, 6]]
print(li2)                                    #[1, 2, 3, [4, 5, 6]]

print(id(li))                                 #内存地址
print(id(li2))                        #内存地址，浅拷贝后内存地址不同

li2[3][0] = 100                         #修改嵌套层数据
print(li)                                   #[1, 2, 3, [4, 5, 6]]
print(li2)                                  #[1, 2, 3, [100, 5, 6]]
print(id(li[3])) 
print(id(li2[3]))                #内存地址，深拷贝后嵌套层内存地址不同
```
* 优点：拷贝后原对象和新对象完全独立，修改新对象不会影响原对象
* 缺点：拷贝速度慢，占用空间大，拷贝效率低

6.3 可变类型

含义 ：数据内容可以修改的类型，列表、字典、集合都是可变类型

变量名指向内存地址，内存地址指向数据内容，修改数据内容内存地址不变
```
li = [1,2,3]
print(id(li)) #内存地址
li[0] = 100
print(li) #[100, 2, 3]
print(id(li)) #内存地址，修改数据内容内存地址不变。字典,集合同理
```
6.4 不可变类型

含义 ：数据内容不可以修改的类型，整数、浮点数、字符串、元组都是不可变类型

变量名指向内存地址，内存地址指向数据内容，修改数据内容内存地址改变
```
a = 10
print(id(a))
a = 100
print(id(a)) #内存地址，修改数据内容内存地址改变。字符串,元组同理
```